// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

// Authentication and User Management Models
model User {
    id            String    @id @default(uuid()) @db.Uuid
    username      String?   @unique
    email         String    @unique
    emailVerified DateTime?
    name          String?
    image         String?
    password      String? // Hashed password for username/password login
    role          UserRole  @default(USER)
    createdAt     DateTime  @default(now())
    updatedAt     DateTime  @updatedAt

    // Relations
    accounts         Account[]
    sessions         Session[]
    bridges          Bridge[] // User-owned bridges
    settings         UserSettings?
    feedback         Feedback[] // User's feedback submissions
    assignedFeedback Feedback[]    @relation("AssignedFeedback") // Feedback assigned to user

    // Indexes
    @@index([email])
    @@index([role])
    @@map("users")
}

model Account {
    id                String  @id @default(uuid()) @db.Uuid
    userId            String  @db.Uuid
    type              String
    provider          String
    providerAccountId String
    refresh_token     String? @db.Text
    access_token      String? @db.Text
    expires_at        Int?
    token_type        String?
    scope             String?
    id_token          String? @db.Text
    session_state     String?

    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@unique([provider, providerAccountId])
    @@map("accounts")
}

model Session {
    id           String   @id @default(uuid()) @db.Uuid
    sessionToken String   @unique
    userId       String   @db.Uuid
    expires      DateTime
    user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@map("sessions")
}

model VerificationToken {
    identifier String
    token      String   @unique
    expires    DateTime

    @@unique([identifier, token])
    @@map("verificationtokens")
}

// User Settings Model
model UserSettings {
    id                  String  @id @default(uuid()) @db.Uuid
    userId              String  @unique @db.Uuid
    displayName         String?
    organization        String?
    timezone            String  @default("UTC")
    theme               String  @default("system") // light, dark, system
    autoSaveBridges     Boolean @default(true)
    showAdvancedOptions Boolean @default(false)
    defaultAuthType     String  @default("none")

    // Bridge defaults
    defaultTimeout       Int     @default(30000)
    defaultRetryAttempts Int     @default(3)
    enableCaching        Boolean @default(true)
    cacheDuration        Int     @default(300)
    enableRateLimiting   Boolean @default(false)
    requestsPerMinute    Int     @default(100)

    // Notifications
    emailNotifications  Boolean @default(true)
    bridgeFailureAlerts Boolean @default(true)
    weeklyReports       Boolean @default(false)
    maintenanceUpdates  Boolean @default(true)
    webhookUrl          String?
    slackWebhookUrl     String?

    // API Keys
    enableApiAccess   Boolean @default(false)
    allowPublicAccess Boolean @default(false)

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // Relations
    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@map("user_settings")
}

enum UserRole {
    USER
    ADMIN
    MODERATOR
}

enum HttpMethod {
    GET
    POST
    PUT
    DELETE
    PATCH
}

enum BridgeStatus {
    active
    inactive
    error
}

model Bridge {
    id          String  @id @default(uuid()) @db.Uuid
    userId      String  @db.Uuid
    name        String
    slug        String  @unique // UUID-based identifier for routing
    description String?
    baseUrl     String

    // Consolidated authentication config for external API calls
    authConfig Json? // { type: 'none|bearer|apikey|basic', token?, apiKey?, username?, password?, headerName? }

    // Request headers
    headers Json? // Custom headers as JSONB

    // Status
    enabled Boolean      @default(false)
    status  BridgeStatus @default(inactive)

    // Routing and access control
    routingConfig Json? // { type: 'http', customDomain?: string, pathPrefix?: string }
    accessConfig  Json? // { public: boolean, allowedOrigins?: string[], authRequired: boolean } - NOTE: tokens managed separately in AccessToken table

    // Performance settings
    performanceConfig Json? // { timeout: 30000, retryAttempts: 3, rateLimiting?, caching? }

    // MCP Content - Store as JSON for flexibility
    mcpTools     Json? // Array of McpTool objects: [{ name: string, description: string, inputSchema: {...} }]
    mcpPrompts   Json? // Array of McpPrompt objects: [{ name: string, description?: string, arguments?: [...] }]
    mcpResources Json? // Array of McpResource objects: [{ uri: string, name: string, description?: string, mimeType?: string }]

    // Soft delete support
    deletedAt DateTime?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // Relations
    user      User          @relation(fields: [userId], references: [id], onDelete: Cascade)
    endpoints ApiEndpoint[]
    logs      BridgeLog[]
    requests  ApiRequest[]
    tokens    AccessToken[] // Add relation to tokens

    // Indexes for performance
    @@index([userId])
    @@index([slug])
    @@index([status, enabled])
    @@index([userId, status])
    @@map("bridges")
}

model ApiEndpoint {
    id          String     @id @default(uuid()) @db.Uuid
    bridgeId    String     @db.Uuid
    name        String
    method      HttpMethod
    path        String
    description String?

    // Store all endpoint config as JSON for flexibility
    config Json? // { parameters: [], requestBody: {}, responseSchema: {}, timeout?: number }

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // Relations
    bridge   Bridge       @relation(fields: [bridgeId], references: [id], onDelete: Cascade)
    requests ApiRequest[]

    // Indexes
    @@index([bridgeId])
    @@index([bridgeId, method, path])
    @@map("api_endpoints")
}

model BridgeLog {
    id        String   @id @default(uuid()) @db.Uuid
    bridgeId  String   @db.Uuid
    level     String // info, warn, error, debug
    message   String
    metadata  Json? // Additional structured data
    createdAt DateTime @default(now())

    // Relations
    bridge Bridge @relation(fields: [bridgeId], references: [id], onDelete: Cascade)

    // Indexes for log queries and cleanup
    @@index([bridgeId, level, createdAt])
    @@index([level, createdAt]) // For global log queries
    @@index([createdAt]) // For cleanup operations
    @@map("bridge_logs")
}

model ApiRequest {
    id         String  @id @default(uuid()) @db.Uuid
    bridgeId   String  @db.Uuid
    endpointId String? @db.Uuid
    method     String
    path       String

    // Store request/response data as JSON
    requestData  Json? // { headers: {}, body: {}, query: {} }
    responseData Json? // { body: {}, headers: {}, statusCode: number }

    // Performance metrics
    responseTime Int? // in milliseconds
    success      Boolean @default(false)
    errorMessage String?

    createdAt DateTime @default(now())

    // Relations
    bridge   Bridge       @relation(fields: [bridgeId], references: [id], onDelete: Cascade)
    endpoint ApiEndpoint? @relation(fields: [endpointId], references: [id], onDelete: SetNull)

    // Indexes for analytics and performance
    @@index([bridgeId, createdAt])
    @@index([success, createdAt])
    @@index([createdAt]) // For time-based queries and cleanup
    @@map("api_requests")
}

// Access Token Model for MCP Authentication
model AccessToken {
    id          String  @id @default(uuid()) @db.Uuid
    bridgeId    String  @db.Uuid
    token       String  @unique // The actual token string
    name        String // Human-readable token name
    description String? // Optional description

    // Permissions - stored as JSON for flexibility
    permissions Json // Array of permission objects: [{ type: 'tools|resources|prompts|admin', actions: [], constraints?: {} }]

    // Token lifecycle
    isActive   Boolean   @default(true)
    expiresAt  DateTime? // Optional expiration
    createdAt  DateTime  @default(now())
    updatedAt  DateTime  @updatedAt
    lastUsedAt DateTime? // Track usage

    // Metadata for additional info
    metadata Json? // Additional structured data

    // Relations
    bridge Bridge @relation(fields: [bridgeId], references: [id], onDelete: Cascade)

    // Indexes for performance
    @@index([bridgeId])
    @@index([token]) // For auth lookups
    @@index([bridgeId, isActive])
    @@index([expiresAt]) // For cleanup jobs
    @@map("access_tokens")
}

// Feedback Model for user feedback collection
model Feedback {
    id       String           @id @default(uuid()) @db.Uuid
    userId   String           @db.Uuid
    type     FeedbackType
    subject  String
    message  String           @db.Text
    priority FeedbackPriority @default(MEDIUM)
    status   FeedbackStatus   @default(OPEN)

    // Contact information
    contactEmail String?

    // Context information
    pageUrl   String?
    userAgent String?
    metadata  Json? // Additional context data

    // Administrative fields
    adminResponse String?   @db.Text
    assignedTo    String?   @db.Uuid
    resolvedAt    DateTime?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // Relations
    user     User  @relation(fields: [userId], references: [id], onDelete: Cascade)
    assignee User? @relation("AssignedFeedback", fields: [assignedTo], references: [id], onDelete: SetNull)

    // Indexes for filtering and performance
    @@index([userId])
    @@index([type, status])
    @@index([status, createdAt])
    @@index([assignedTo])
    @@map("feedback")
}

enum FeedbackType {
    BUG
    FEATURE
    GENERAL
    SUPPORT
    SECURITY
}

enum FeedbackPriority {
    LOW
    MEDIUM
    HIGH
    CRITICAL
}

enum FeedbackStatus {
    OPEN
    IN_PROGRESS
    RESOLVED
    CLOSED
    DUPLICATE
}
